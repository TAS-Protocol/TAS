import axios from "axios";
import lighthouse from "@lighthouse-web3/sdk";
import { getJWT } from "@lighthouse-web3/kavach";
import { CONTRACTS } from "@/constants/contracts/index";

const LighthouseChains = {
  80001: {
    name: "Mumbai",
  },
  5: {
    name: "Goerli",
  },
  10: {
    name: "OptimismGoerli",
  },
  11: {
    name: "",
  },
  3124: {
    name: "Calibration",
  },
};

export const getIpfsGatewayUri = (cidOrIpfsUri) => {
  const LIGHTHOUSE_IPFS_GATEWAY =
    "https://gateway.lighthouse.storage/ipfs/{cid}";
  // const cid = cidOrIpfsUri.replace("ipfs://", "");
  return LIGHTHOUSE_IPFS_GATEWAY.replace("{cid}", cidOrIpfsUri);
};

export const getMetadata = async (cidOrIpfsUri) => {
  const LighthouseGatewayLink = getIpfsGatewayUri(cidOrIpfsUri);
  console.log(`Getting metadata ${cidOrIpfsUri} at ${LighthouseGatewayLink}`);
  const link = LighthouseGatewayLink.replace("ipfs://", "");
  try {
    const result = await axios.get(link);
    return result.data;
  } catch (err) {
    console.error(err);
    return null;
  }
};

export const getData = async (cidOrIpfsUri) => {
  let LighthouseGatewayLink = getIpfsGatewayUri(cidOrIpfsUri);

  console.log(`Getting data ${cidOrIpfsUri} at ${nftStorageGatewayLink}`);
  const link = LighthouseGatewayLink.replace("ipfs://", "");

  try {
    const result = await axios.get(link);
    return result.data;
  } catch (err) {
    console.error(err);
    return null;
  }
};

const progressCallback = (progressData) => {
  let percentageDone =
    100 - (progressData?.total / progressData?.uploaded)?.toFixed(2);
  return percentageDone;
};

export const uploadFile = async (file, apiKey, setUploadProgress) => {
  const progressCallback = (progressData) => {
    const percentageDone =
      100 - (progressData?.total / progressData?.uploaded)?.toFixed(2);
    setUploadProgress(percentageDone); // Update the progress state
  };
  const output = await lighthouse.upload(
    file,
    apiKey,
    false,
    null,
    progressCallback
  );
  console.log("File Status:", output);
  console.log(
    "Visit at https://gateway.lighthouse.storage/ipfs/" + output.data.Hash
  );
  return output.data;
};

/* Deploy file along with encryption */
export const uploadFileEncrypted = async (
  file,
  apiKey,
  address,
  signEncryption,
  setUploadProgress
) => {
  const progressCallback = (progressData) => {
    const percentageDone =
      100 - (progressData?.total / progressData?.uploaded)?.toFixed(2);
    setUploadProgress(percentageDone); // Update the progress state
  };

  const output = await lighthouse.uploadEncrypted(
    file,
    apiKey,
    address,
    signEncryption,
    null,
    progressCallback
  );
  console.log(output);
  return output.data;
};

export const generateLighthouseJWT = async (address, signEncryption) => {
  const response = await getJWT(address, signEncryption);
  if (response.JWT) {
    localStorage.setItem(`lighthouse-jwt-${address}`, response.JWT);
    return response.JWT;
  }

  if (response.error) {
    return null;
  }
};

export const decrypt = async (cid, address, signedMessage) => {
  // Fetch file encryption key
  /*
    fetchEncryptionKey(cid, publicKey, signedMessage)
      Parameters:
        CID: CID of the file to decrypt
        publicKey: public key of the user who has access to file or owner
        signedMessage: message signed by the owner of publicKey
  */
  const keyObject = await lighthouse.fetchEncryptionKey(
    cid,
    address,
    signedMessage
  );

  // Decrypt file
  /*
    decryptFile(cid, key, mimeType)
      Parameters:
        CID: CID of the file to decrypt
        key: the key to decrypt the file
        mimeType: default null, mime type of file
  */

  const fileType = "application/json";
  const decrypted = await lighthouse.decryptFile(
    cid,
    keyObject.data.key,
    fileType
  );
  /*
    Response: blob
  */
  return decrypted;
};

export const applyAccessConditions = async (
  cid,
  chainID,
  uid,
  address,
  jwt
) => {
  // CID on which you are applying encryption
  // CID is generated by uploading a file with encryption
  // Only the owner of the file can apply access conditions

  // Conditions to add
  const conditions = [
    {
      id: 1,
      chain: "Mumbai",
      method: "hasAccess",
      standardContractType: "Custom",
      contractAddress: "0x6d586fcdd18da8f39783daa09551682df2eb76cc",
      returnValueTest: {
        comparator: "==",
        value: "1",
      },
      parameters: [":address", uid],
      inputArrayType: ["address", "bytes32"],
      outputType: "uint256",
    },
  ];

  // Aggregator is what kind of operation to apply to access conditions
  // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
  const aggregator = "([1])";

  /*
    accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
      Parameters:
        publicKey: owners public key
        CID: CID of the file to decrypt
        signedMessage: message signed by the owner of publicKey
        conditions: should be in a format like above
        aggregator: aggregator to apply conditions
  */
  const response = await lighthouse.applyAccessCondition(
    address,
    cid,
    jwt,
    conditions,
    aggregator
  );

  return response
  /*
    {
      data: {
        cid: "QmZkEMF5y5Pq3n291fG45oyrmX8bwRh319MYvj7V4W4tNh",
        status: "Success"
      }
    }
  */
};
