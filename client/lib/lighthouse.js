import axios from "axios";
import lighthouse from "@lighthouse-web3/sdk";
import { getJWT } from '@lighthouse-web3/kavach';


export const getIpfsGatewayUri = (cidOrIpfsUri) => {
  const LIGHTHOUSE_IPFS_GATEWAY = "https://gateway.lighthouse.storage/ipfs/{cid}";
  // const cid = cidOrIpfsUri.replace("ipfs://", "");
  return LIGHTHOUSE_IPFS_GATEWAY.replace("{cid}", cidOrIpfsUri);
};

export const getMetadata = async (cidOrIpfsUri) => {
  const LighthouseGatewayLink = getIpfsGatewayUri(cidOrIpfsUri);
  console.log(`Getting metadata ${cidOrIpfsUri} at ${LighthouseGatewayLink}`);
  const link = LighthouseGatewayLink.replace("ipfs://", "");
  try {
    const result = await axios.get(link);
    return result.data;
  } catch (err) {
    console.error(err);
    return null;
  }
};


export const getData = async (cidOrIpfsUri) => {
  let LighthouseGatewayLink = getIpfsGatewayUri(cidOrIpfsUri);

  console.log(`Getting data ${cidOrIpfsUri} at ${nftStorageGatewayLink}`);
  const link = LighthouseGatewayLink.replace("ipfs://", "");

  try {
    const result = await axios.get(link);
    return result.data;
  } catch (err) {
    console.error(err);
    return null;
  }
};

const progressCallback = (progressData) => {
  let percentageDone =
    100 - (progressData?.total / progressData?.uploaded)?.toFixed(2);
  console.log(percentageDone);
};

export const uploadFile = async (file, apiKey) => {

  const output = await lighthouse.upload(
    file,
    apiKey,
    false,
    null,
    progressCallback
  );
  console.log("File Status:", output);
  console.log(
    "Visit at https://gateway.lighthouse.storage/ipfs/" + output.data.Hash
  );
  return output.data
};

/* Deploy file along with encryption */
export const uploadFileEncrypted = async (file, apiKey , address, signEncryption) => {

 const output = await lighthouse.uploadEncrypted(
    file,
    apiKey,
    address,
    signEncryption,
    null
  );
  console.log(output)
  return output.data
};

export const generateLighthouseJWT = async(address, signEncryption) => {
  const response = await getJWT(address, signEncryption);
    if (response.JWT) {
        localStorage.setItem(`lighthouse-jwt-${address}`, response.JWT);
        return response.JWT;
    }
    
    if(response.error){
        return null
    }
}

export const decrypt = async(cid, address, signedMessage) =>{
  // Fetch file encryption key
  /*
    fetchEncryptionKey(cid, publicKey, signedMessage)
      Parameters:
        CID: CID of the file to decrypt
        publicKey: public key of the user who has access to file or owner
        signedMessage: message signed by the owner of publicKey
  */
  const keyObject = await lighthouse.fetchEncryptionKey(
    cid,
    address,
    signedMessage
  );

  // Decrypt file
  /*
    decryptFile(cid, key, mimeType)
      Parameters:
        CID: CID of the file to decrypt
        key: the key to decrypt the file
        mimeType: default null, mime type of file
  */
 
  const fileType = "application/json"
  const decrypted = await lighthouse.decryptFile(cid, keyObject.data.key, fileType);
  console.log(decrypted)
  /*
    Response: blob
  */

  // View File
  const url = URL.createObjectURL(decrypted);
  return url
}

export const applyAccessConditions = async(address, signedMessage) =>{
  // CID on which you are applying encryption
  // CID is generated by uploading a file with encryption
  // Only the owner of the file can apply access conditions
  const cid = "QmUk8oYGfADHx8Dg6JVU1DpNSkS3oPPXtuhdDkU6p4jcxk";

  // Conditions to add
  const conditions = [
    {
      id: 1,
      chain: "Optimism",
      method: "getBlockNumber",
      standardContractType: "",
      returnValueTest: {
        comparator: ">=",
        value: "1"
      },
    },
  ];

  // Aggregator is what kind of operation to apply to access conditions
  // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
  const aggregator = "([1])";

  /*
    accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
      Parameters:
        publicKey: owners public key
        CID: CID of the file to decrypt
        signedMessage: message signed by the owner of publicKey
        conditions: should be in a format like above
        aggregator: aggregator to apply conditions
  */
  const response = await lighthouse.applyAccessCondition(
    address,
    cid,
    signedMessage,
    conditions,
    aggregator
  );

  console.log(response);
  /*
    {
      data: {
        cid: "QmZkEMF5y5Pq3n291fG45oyrmX8bwRh319MYvj7V4W4tNh",
        status: "Success"
      }
    }
  */
}
